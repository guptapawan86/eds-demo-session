const reorderDOM = {
  selectorEls: null, headerEl: null, capturedEls: null, capturedElsQuery: null, clonedEls: [], cOrder: null, cMax: null, useStatic: null, selectorElsQuery: null, staticEl: null, staticElQuery: null, addListeners() { window.addEventListener('channel:reorder-dom', (e) => { if (this.useStatic = e.detail.useStatic, this.cOrder = e.detail.order, this.cMax = e.detail.max, this.updateElements(), void 0 !== e.detail.selectorIndex) { document.querySelectorAll(this.selectorElsQuery).item(e.detail.selectorIndex).focus(); } }); }, updateElements() { !this.useStatic && this.updateSelectors(), !this.useStatic && this.updateHeadersAX(), !this.useStatic && this.updateRows(), this.useStatic && this.updateStatic(), this.getStatSubCopyHeight(); }, arrayFromNodeList(e) { const t = []; return e.forEach((e) => { t.push(e); }), t; }, updateStatic() { this.clonedEls.forEach((e, t) => { const i = this.capturedEls[t]; const r = e.cloneNode(!0); const n = r.querySelector('[role=rowheader]'); const s = r.querySelector('[id=hidden-columnheader]'); const o = []; this.cOrder.forEach((e, t) => { const i = `[index="${e}"]`; const n = r.querySelector(i).parentElement; o.push(n); }), o.reverse().forEach((e, t) => { e.setAttribute('added', !0), r.prepend(e); }); for (let e = 0; e < r.children.length; e++) { const t = r.children[e]; t.getAttribute('role') !== 'rowheader' && t.getAttribute('id') !== 'hidden-columnheader' && (t.style.order = 'unset', this.toggleVisibility(t, e < this.cMax)); }s && r.prepend(s), r.prepend(n), r.setAttribute('added', !0), i.innerHTML = r.innerHTML; }); }, updateHeadersAX() { let e = `<div role="columnheader">${getComputedStyle(document.querySelector('.channel-compare')).getPropertyValue('--column-header-empty-cell')}</div>`; document.querySelectorAll(this.selectorElsQuery).forEach((t, i) => { const r = t.querySelector('[selected=true]').innerText.trim(); t.parentElement.parentElement.style.display === 'flex' && (e += `<div role="columnheader">${r}</div>`); }), this.headerEl.innerHTML = e; }, updateSelectors() { document.querySelectorAll(this.selectorElsQuery).forEach((e, t) => { e.replaceWith(this.selectorEls[t]); }), this.cOrder.forEach((e, t) => { const i = this.selectorEls[t]; let r = 0; for (let t = 0; t < i.options.length; t++) { const n = i.options[t]; const s = Number(n.value) === e; s && (r = t), n.removeAttribute('selected'), n.setAttribute('selected', s), n.removeAttribute('aria-selected'), n.setAttribute('aria-selected', s); }i.selectedIndex = r; }); for (let e = 0; e < this.selectorEls.length; e++) { const t = this.selectorEls[e]; const i = e < this.cMax; this.toggleVisibility(t.parentElement.parentElement, i); } }, updateRows() { this.clonedEls.forEach((e, t) => { const i = this.capturedEls[t]; const r = e.cloneNode(!0); const n = r.querySelector('[role=rowheader]'); const s = []; this.cOrder.forEach((e) => { const t = `[index="${e}"]`; const i = r.querySelector(t).parentElement; s.push(i); }), s.reverse().forEach((e) => { r.prepend(e); }); for (let e = 0; e < r.children.length; e++) { const t = r.children[e]; t.getAttribute('role') !== 'rowheader' && (t.style.order = 'unset', this.toggleVisibility(t, e < this.cMax)); }r.prepend(n), i.innerHTML = r.innerHTML; }); }, getStatSubCopyHeight() { const e = document.getElementsByClassName('compare-template-preview-item-stat'); if (e) { const t = []; Array.from(e).forEach((e, i) => { const r = e.children; const n = []; Array.from(r).forEach((e) => { e.style.visibility === 'visible' && n.push(e.children[0].children[0]); }); const s = []; n.forEach((e) => { const r = []; let n = 0; Array.from(e.children).forEach((e) => { const s = e; s.style.height = '', s.children[0].className.includes('stat-value') || s.children[0].className.includes('image') || s.children[0].className.includes('mdash') || (r.push(s), void 0 === t[i] ? t[i] = [s.offsetHeight] : void 0 === t[i][n] ? t[i][n] = s.offsetHeight : void 0 !== t[i][n] && s.offsetHeight > t[i][n] && (t[i][n] = s.offsetHeight), n++); }), s.push(r); }), s.forEach((e) => { e.forEach((e, r) => { e.style.height = `${t[i][r]}px`; }); }); }); } }, toggleVisibility(e, t) { e.style.visibility = t ? 'visible' : 'hidden', e.style.display = t ? 'flex' : 'none', e.style.order = 'unset'; }, init(e, t, i, r, n) { this.useStatic = n, this.capturedEls = document.querySelectorAll(e), this.capturedElsQuery = e, this.headerEl = document.querySelector(i), this.selectorEls = document.querySelectorAll(t), this.selectorElsQuery = t, this.staticElQuery = r, this.staticEl = this.useStatic && document.querySelector(this.staticElQuery).cloneNode(!0), this.useStatic = n, this.clonedEls = this.arrayFromNodeList(this.capturedEls), this.addListeners(); },
}; const viewportManager = {
  nState: null, cState: null, init() { this.addListeners(); }, addListeners() { const e = { small: window.matchMedia('(max-width: 734px)'), medium: window.matchMedia('(min-width: 735px) and (max-width: 1068px)'), large: window.matchMedia('(min-width: 1069px)') }; Object.keys(e).forEach((t) => { const i = e[t]; typeof i.addEventListener !== 'function' ? i.addListener(() => { i.matches && this.viewportObserve(t); }) : i.addEventListener('change', () => { i.matches && this.viewportObserve(t); }), i.matches && this.viewportObserve(t); }); }, viewportObserve(e) { this.nState = e, this.cState !== this.nState && (this.cState = this.nState, this.dispatch(this.cState)); }, dispatch(e) { const t = new CustomEvent('channel:viewport-change', { detail: e }); window.dispatchEvent(t); },
}; const orientationManager = { orienation: null, init() { window.matchMedia('(orientation: portrait)').addEventListener('change', (e) => { e.matches ? this.orienation = 'portrait' : this.orienation = 'landscape', this.dispatch(this.orienation); }); }, dispatch(e) { const t = new CustomEvent('channel:orientation-change', { detail: e }); window.dispatchEvent(t); } }; const selectorManager = {
  init(e, t) {
    const i = document.querySelectorAll(e); i.forEach((e, t) => {
      e.addEventListener('change', () => {
        const r = e.selectedIndex; const n = e.value; const s = Number(e.options[r].getAttribute('value')); this.dispatch({
          elIndex: t, selectedIndex: s, value: n, selectorEls: i,
        }), e.focus();
      });
    });
  },
  dispatch(e) { const t = new CustomEvent('channel:pre-user-select', { detail: e }); window.dispatchEvent(t); },
}; const buyButtonManager = {
  buyButtonQuery: null, init(e) { this.buyButtonQuery = e, this.addListeners(), this.attachButtonListeners(); }, addListeners() { window.addEventListener('channel:reorder-dom', () => { this.attachButtonListeners(); }); }, attachButtonListeners() { document.querySelectorAll(this.buyButtonQuery).forEach((e) => { e.addEventListener('click', (t) => { const i = t.screenX === 0 && t.screenY === 0 ? 'Keyboard Interaction' : 'Mouse Click'; this.dispatch({ productName: e.id, eventSource: i }); }); }); }, dispatch(e) { const t = new CustomEvent('channel:buy-button-click', { detail: e }); window.dispatchEvent(t); },
}; const dataManager = {
  order: null,
  viewportKey: null,
  viewportOrder: null,
  viewportMax: null,
  init(e, t) { this.order = e, this.useStatic = t, this.addListeners(); },
  viewportChange(e) { this.viewportKey = e, this.viewportOrder = this.order[this.viewportKey], this.viewportMax = this.order.max[this.viewportKey], this.dispatch({ order: this.viewportOrder, max: this.viewportMax, useStatic: this.useStatic }); },
  blurSelects(e) { document.querySelectorAll(e).forEach((e) => { e.blur(); }); },
  flattenOrders() { this.viewportOrder = this.order[this.viewportKey], this.viewportMax = this.order.max[this.viewportKey], ['small', 'medium', 'large'].forEach((e) => { this.order[e] = this.viewportOrder; }); },
  getLineupInfo(e, t) { const i = {}; return e.forEach((e, r) => { i[r] = { columnIndex: r, deviceName: e.options[e.selectedIndex].text, hasChanged: r === t }; }), i; },
  userSelect(e) {
    const { elIndex: t, selectedIndex: i } = e; const r = this.viewportOrder[t]; const n = this.viewportOrder.find((e) => e === i); const s = this.viewportOrder.indexOf(n); void 0 !== n ? (this.viewportOrder[s] = r, this.viewportOrder[t] = n) : this.viewportOrder[t] = i, this.flattenOrders(), this.dispatch({
      order: this.viewportOrder, max: this.viewportMax, useStatic: this.useStatic, selectorIndex: t,
    }), e.deviceLineup = this.getLineupInfo(e.selectorEls, t), delete e.selectorEls; const o = Object.keys(e.deviceLineup).slice(0, this.viewportMax).reduce((t, i) => (t[i] = e.deviceLineup[i], t), {}); this.dispatchPostUserSelect({ deviceLineup: o });
  },
  addListeners() { window.addEventListener('channel:pre-user-select', (e) => { this.userSelect(e.detail); }), window.addEventListener('channel:user-refresh', (e) => { this.dispatch({ order: this.viewportOrder, max: this.viewportMax, useStatic: this.useStatic }); }), window.addEventListener('channel:viewport-change', (e) => { this.viewportChange(e.detail), this.blurSelects(this.selectorElsQuery); }), window.addEventListener('change:orientation-change', () => { this.blurSelects(this.selectorElsQuery); }); },
  dispatch(e) { const t = new CustomEvent('channel:reorder-dom', { detail: e }); window.dispatchEvent(t); },
  dispatchPostUserSelect(e) { const t = new CustomEvent('channel:user-select', { detail: e }); window.dispatchEvent(t); },
}; const channelCompare = { inited: !1, init(e = null) { if (this.inited) return; let t; if (this.isDev = window.location.host.indexOf('127.0.0.1') > -1, e)t = e; else if (!e) { const e = document.querySelector('[data-channel-html-compare]'); if (!e) return void console.warn('channelCompare: element[data-channel-html-compare not found]'); try { const i = e.getAttribute('data-channel-html-compare'); t = JSON.parse(i); } catch (e) { return void console.warn('channelCompare: error parsing JSON', e); } } if (t.isConfigurableCompare) { const e = { large: [], medium: [], small: [] }; let i = []; const r = document.querySelector('[data-compare-lineup]'); if (r) try { const e = r.getAttribute('data-compare-lineup'); const t = JSON.parse(e !== null && void 0 !== e ? e : '{}'); t['apple-compare'] && (i = t['apple-compare']); } catch (e) { return void console.warn('channelCompare: error parsing JSON', e); } const n = new URL(window.location.toLocaleString()).searchParams; n.get('apple-compare') && (i = n.get('apple-compare').split(',')), Object.keys(e).forEach((t) => { let r; e[t] = [...new Set((r = i === null || void 0 === i ? void 0 : i.map((e) => Number(e) - 1)) !== null && void 0 !== r ? r : [])].filter((e) => Number(e) >= 0); }), t.order = this.orderOverwrite(t.order, e); } const i = t.order; const r = t.headerEl; const n = t.selectorEls; const s = t.swapEls; const o = t.staticEl; const a = t.useStatic; reorderDOM.init(s, n, r, o, a), !a && selectorManager.init(n), buyButtonManager.init('.compare-button'), dataManager.init(i, a), viewportManager.init(), orientationManager.init(), this.inited = !0; }, orderOverwrite(e, t) { const i = { ...e }; return Object.keys(t).forEach((e) => { const r = i[e].filter((i) => !t[e].includes(i)); const n = [...t[e], ...r].slice(0, 5); i[e] = n; }), i; } }; window.addEventListener('pageshow', (e) => { const { persisted: t } = e; if (t)window.addEventListener('scroll', () => { const e = new CustomEvent('channel:user-refresh'); window.dispatchEvent(e); }, { once: !0 }); else { channelCompare.init(), document.querySelector('.channel-compare').classList.remove('channel-compare--hidden'); } });
